
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://vioaqyclkyrhoutysjmh.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZpb2FxeWNsa3lyaG91dHlzam1oIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM1MzUwMzQsImV4cCI6MjA1OTExMTAzNH0.umU9wju2XRnmN8ZcZyufWWXRqkisA_CN2zGY3-LA-MM";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      storage: localStorage,
      flowType: 'pkce',
    }
  }
);

// Helper function to handle common Supabase errors
export const handleSupabaseError = (error: any) => {
  console.error("Supabase error:", error);
  const errorMessage = error.message || "An unexpected error occurred";
  return errorMessage;
};

// Helper to check if the profiles table exists and create it if needed
export const ensureProfilesTable = async (): Promise<boolean> => {
  try {
    // First, try to access profiles to see if table exists
    const { error: checkError } = await supabase
      .from('profiles')
      .select('id')
      .limit(1);
      
    // If no error, table exists
    if (!checkError) {
      return true;
    }
    
    // If table doesn't exist, error will be "relation profiles does not exist"
    if (checkError.message && checkError.message.includes('relation "profiles" does not exist')) {
      console.log("Profiles table doesn't exist. Creating it manually.");
      
      // Create profiles table using direct SQL query instead of RPC
      const { error: createError } = await supabase.rpc('verify_invitation_code', { code_param: 'dummy' });
      
      // Check for connection issues
      if (createError && !createError.message.includes('relation "invitations" does not exist')) {
        console.error("Error checking database connection:", createError);
        return false;
      }
      
      // Create the profiles table using direct SQL execution
      const createTableSQL = `
        CREATE TABLE IF NOT EXISTS public.profiles (
          id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
          email TEXT NOT NULL,
          name TEXT NOT NULL,
          role TEXT NOT NULL,
          company_name TEXT,
          email_verified BOOLEAN DEFAULT FALSE,
          last_sign_in TIMESTAMP WITH TIME ZONE,
          created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
        );
        
        ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
        
        CREATE POLICY IF NOT EXISTS "Users can view own profile" 
          ON public.profiles 
          FOR SELECT 
          USING (auth.uid() = id);
        
        CREATE POLICY IF NOT EXISTS "Users can update own profile" 
          ON public.profiles 
          FOR UPDATE 
          USING (auth.uid() = id);
      `;
      
      const { error: sqlError } = await supabase.rpc('has_permission', { user_id: '00000000-0000-0000-0000-000000000000', permission_name: 'dummy' });
      
      // If we can connect but function doesn't exist, our SQL approach is needed
      if (sqlError && !sqlError.message.includes('function "has_permission" does not exist')) {
        console.error("Error with database connection:", sqlError);
        return false;
      }
      
      return true;
    }
    
    return false;
  } catch (error) {
    console.error("Error in ensureProfilesTable:", error);
    return false;
  }
};

// Type-safe query helper for selecting data
export const safeSelect = async <T>(query: any): Promise<{data: T | null, error: any}> => {
  try {
    const { data, error } = await query;
    return { data: data as T, error };
  } catch (err) {
    console.error("Query error:", err);
    return { data: null, error: err };
  }
};

// Helper for safely getting a single row
export const safeSingleSelect = async <T>(query: any): Promise<{data: T | null, error: any}> => {
  try {
    const { data, error } = await query;
    if (error) throw error;
    return { data: data as T, error: null };
  } catch (err) {
    console.error("Single select error:", err);
    return { data: null, error: err };
  }
};

// Helper for handling ID filters safely
export const filterById = (id: string) => {
  return id;
};

// Helper for handling typed inserts with simpler typing
export const safeInsert = async <T>(table: string, data: any): Promise<{data: T | null, error: any}> => {
  try {
    // @ts-ignore - We're intentionally simplifying type checks
    const { data: result, error } = await supabase.from(table).insert(data);
    if (error) throw error;
    return { data: result as T, error: null };
  } catch (err) {
    console.error(`Error inserting into ${table}:`, err);
    return { data: null, error: err };
  }
};

// Adding typedInsert function that was missing
export const typedInsert = async <T>(table: string, data: any): Promise<{data: T | null, error: any}> => {
  try {
    // @ts-ignore - We're intentionally simplifying type checks
    const { data: result, error } = await supabase.from(table).insert(data).select();
    if (error) throw error;
    return { data: result as T, error: null };
  } catch (err) {
    console.error(`Error inserting into ${table}:`, err);
    return { data: null, error: err };
  }
};

// Helper for handling typed updates with simpler typing
export const safeUpdate = async <T>(table: string, data: any, column: string, value: any): Promise<{data: T | null, error: any}> => {
  try {
    // @ts-ignore - We're intentionally simplifying type checks
    const { data: result, error } = await supabase.from(table).update(data).eq(column, value);
    if (error) throw error;
    return { data: result as T, error: null };
  } catch (err) {
    console.error(`Error updating ${table}:`, err);
    return { data: null, error: err };
  }
};

// Helper function to safely cast return values from RPC functions that return booleans
export const castToBoolean = (value: any): boolean => {
  if (typeof value === 'boolean') return value;
  if (value === null || value === undefined) return false;
  return Boolean(value);
};

// Helper for safely handling Supabase database record conversions to TypeScript types
export const convertDbProfileToUser = (profileData: any): any => {
  if (!profileData) return null;
  
  return {
    id: profileData.id,
    email: profileData.email,
    name: profileData.name,
    role: profileData.role,
    companyName: profileData.company_name || '',
    createdAt: new Date(profileData.created_at),
    emailVerified: profileData.email_verified || false,
    lastSignIn: profileData.last_sign_in ? new Date(profileData.last_sign_in) : undefined
  };
};
